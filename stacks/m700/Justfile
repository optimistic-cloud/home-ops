# TODO: rename provider_env_file to backup_type where applicable

set dotenv-load
set dotenv-filename := '.ops.env'

# info, debug, warn, error
export NU_LOG_LEVEL := "info"
export RESTIC_DOCKER_IMAGE := "restic/restic:0.18.1"
export HOSTNAME := "m700"

alias r := restart
alias d := down

systemd_conf_path := "./conf.d/systemd/user"

help:
    just --list --list-submodules

[group('docker')]
[doc('Restart the stack')]
restart:
    docker compose down --remove-orphans
    docker compose up -d --remove-orphans

#[group('docker')]
#[doc('Start the stack')]
#up:
#    docker compose up -d --remove-orphans

#[group('docker')]
#[doc('Stop the stack')]
#down:
#    docker compose down --remove-orphans

[group('docker')]
[doc('Get logs for a service')]
logs service:
    docker compose logs -f {{service}}

[group('docker')]
[doc('Start application stack')]
up app:
    cd {{app}} && docker compose up -d --remove-orphans

[group('docker')]
[doc('Stop application stack')]
down app:
    cd {{app}} && docker compose down --remove-orphans

[group('backup')]
[doc('List providers for an application')]
providers app:
    #!/usr/bin/env nu
    ls conf.d/backup/{{app}}.*.restic.env | get name | each { split row '.' | get 2 }

[group('backup')]
[doc('Init repository')]
init app provider:
    just _restic-run {{app}} {{provider}} init

[group('backup')]
[doc('Get snapshots')]
snapshots app provider:
    just _restic-run {{app}} {{provider}} --quiet snapshots --latest 5

[group('backup')]
[doc('List files in the snapshot')]
ls app provider:
    just _restic-run {{app}} {{provider}} --quiet ls latest

[group('backup')]
[doc('Get stats of the repository')]
stats app provider:
    just _restic-run {{app}} {{provider}} --quiet stats

[group('backup')]
[doc('Unlock repository')]
unlock app provider:
    just _restic-run {{app}} {{provider}} --quiet unlock

[group('backup')]
[doc('Prune snapshots')]
prune app provider:
    just _restic-run {{app}} {{provider}} --quiet prune

[group('backup')]
[doc('Prune snapshots')]
prune-all app:
    #!/usr/bin/env nu
    ls conf.d/backup/{{app}}.*.restic.env | get name | each {|e| 
        let provider_env_file = $e
        nu ./conf.d/backup/restic.nu prune --provider-env-file $provider_env_file
    }

[group('backup')]
[doc('Backup application')]
backup-all app:
    #!/usr/bin/env nu
    let env_files = (ls conf.d/backup/{{app}}.*.restic.env | get name)
    nu ./conf.d/backup/{{app}}-many.nu ...$env_files

[group('backup')]
[doc('Backup application')]
backup app provider:
    nu ./conf.d/backup/{{app}}-one.nu {{provider}} ./conf.d/backup/{{app}}.{{provider}}.restic.env

[group('backup')]
[doc('Restore backup for an application')]
restore app provider restore_path:
    #!/usr/bin/env bash
    set -euo pipefail

    if [[ "{{provider}}" != "local" && "{{provider}}" != "onsite" && "{{provider}}" != "offsite" ]]; then
        echo "Invalid provider '{{provider}}'. Use: local, onsite, or offsite." >&2
        exit 1
    fi

    env_file="./conf.d/backup/{{app}}.{{provider}}.restic.env"
    if [[ ! -f "$env_file" ]]; then
        echo "Env file not found: $env_file" >&2
        exit 1
    fi

    target="{{restore_path}}"
    if [[ -e "$target" ]]; then
        echo "Restore path already exists: $target" >&2
        exit 1
    fi
    mkdir -p "$target"

    docker_args=(
        "--hostname" "${HOSTNAME}"
        "--env-file" "$env_file"
        "-e" "TZ=Europe/Berlin"
        "-v" "${HOME}/.cache/restic:/root/.cache/restic"
        "-v" "$target:/data:rw"
    )

    if [[ "{{provider}}" == "local" ]]; then
        repo_path="$(grep -m1 '^RESTIC_REPOSITORY=' "$env_file" | cut -d'=' -f2-)"
        if [[ -z "$repo_path" ]]; then
            echo "RESTIC_REPOSITORY is missing in $env_file" >&2
            exit 1
        fi
        docker_args+=("-v" "$repo_path:$repo_path")
    fi

    docker run --rm -i "${docker_args[@]}" "{{RESTIC_DOCKER_IMAGE}}" restore latest --target /data

[private]
_restic-run app backup_type +args:
    #!/usr/bin/env bash
    set -euo pipefail

    if [[ "{{backup_type}}" != "local" && "{{backup_type}}" != "onsite" && "{{backup_type}}" != "offsite" ]]; then
        echo "Invalid backup_type '{{backup_type}}'. Use: local, onsite, or offsite." >&2
        exit 1
    fi

    env_file="./conf.d/backup/{{app}}.{{backup_type}}.restic.env"
    if [[ ! -f "$env_file" ]]; then
        echo "Env file not found: $env_file" >&2
        exit 1
    fi

    docker_args=(
        "--hostname" "${HOSTNAME}"
        "--env-file" "$env_file"
        "-e" "TZ=Europe/Berlin"
        "-v" "${HOME}/.cache/restic:/root/.cache/restic"
    )

    if [[ "{{backup_type}}" == "local" ]]; then
        repo_path="$(grep -m1 '^RESTIC_REPOSITORY=' "$env_file" | cut -d'=' -f2-)"
        if [[ -z "$repo_path" ]]; then
            echo "RESTIC_REPOSITORY is missing in $env_file" >&2
            exit 1
        fi
        docker_args+=("-v" "$repo_path:$repo_path")
    fi

    docker run --rm -i "${docker_args[@]}" "{{RESTIC_DOCKER_IMAGE}}" {{args}}

[group('backup')]
[doc('Forget old snapshots')]
forget-prune app backup_type keep-within="365d":
    just _restic-run {{app}} {{backup_type}} forget --keep-within {{keep-within}}

[group('backup')]
[doc('Send a test ping to Healthchecks for a slug')]
healthcheck-ping slug:
    #!/usr/bin/env bash
    set -euo pipefail

    if [[ -z "${HC_HOST:-}" || -z "${HC_PING_KEY:-}" ]]; then
        echo "HC_HOST and HC_PING_KEY must be set in .ops.env" >&2
        exit 1
    fi

    url="https://${HC_HOST}/ping/${HC_PING_KEY}/{{slug}}?create=1"
    curl --fail --silent --show-error "$url" >/dev/null
    echo "Ping sent: $url"

[group('systemd')]
[doc('Configure backup timers')]
install-timers: stop-timers && enable-timers start-timers
    rm -rf ~/.config/systemd/user
    mkdir -p ~/.config/systemd/user
    cp -r {{systemd_conf_path}}/* ~/.config/systemd/user/
    systemctl --user daemon-reload

#[group('systemd')]
#[doc('Start manually backup timer for an application')]
#start-timer app:
#    systemctl --user start {{app}}-backup-.service

[group('systemd')]
[doc('Start backup timers')]
start-timers:
    #!/usr/bin/env nu
    ls {{systemd_conf_path}}/*.timer | get name | each {|e| 
        let timer = ($e | path basename)
        systemctl --user start --now $timer
    }
    ignore

[group('systemd')]
[doc('Stop backup timers')]
stop-timers:
    #!/usr/bin/env nu
    ls {{systemd_conf_path}}/*.timer | get name | each {|e| 
        let timer = ($e | path basename)
        systemctl --user stop --now $timer | ignore
    }
    ignore

[group('systemd')]
[doc('Run timer')]
run-timer app backup_type:
    systemctl --user start {{app}}-backup@{{backup_type}}.service

[group('systemd')]
[doc('Enable backup timers')]
enable-timers:
    #!/usr/bin/env nu
    ls {{systemd_conf_path}}/*.timer | get name | each {|e| 
        let timer = ($e | path basename)
        systemctl --user enable --now $timer
    }
    ignore

[group('systemd')]
[doc('Log backup timer')]
log-timer app:
    journalctl --user -xeu backup-{{app}}.service

[group('systemd')]
[doc('List backup timers')]
list-timers:
    systemctl --user list-timers

[group('systemd')]
[doc('Uninstall backup timers (disable + remove unit files)')]
uninstall-timers:
    #!/usr/bin/env bash
    set -euo pipefail
    for t in $(systemctl --user list-unit-files --type=timer | awk '/backup/ {print $1}'); do
        systemctl --user disable --now "$t" || true
    done
    rm -f ~/.config/systemd/user/*backup*.timer ~/.config/systemd/user/*backup*@.service
    systemctl --user daemon-reload
    systemctl --user reset-failed